import os
import logging
import shutil
import json
import codecs # Import codecs
import re 

# NO BORRAR ESTE COMENTARIO
# GUIA
# ESTO CASI FUNCIONA BIEN; SE SOLUCIONO EL PROBLEMA DONDE LOS SALTOS DE LINEA DENTRO DEL CODIGO (EJEMPLO UN LOG QUE CONTENIA INDICACIONES DE SALTO DE LINEA; SE MANEA BIEN SEGUN EL TEST, Y LOS CARACTERES ASI COMO  usarÃ¡ TAMBIEN SE SOLUCIONA PERO NO SE ARREGLA Funci\\u00f3n, ¿por que? no lo se, pero rompe te toda la logica cuando se intenta, lo que se me ocurre es otra funcion que despues de que aplicarCambiosSobrescritura haga su trabajo, procesa a solucionar Funci\\u00f3n, no hay que modificar nada de lo que ya hace, sola otra etapa
# REVISIÓN: La guía sugiere una etapa extra, pero usar 'unicode_escape' en el orden correcto debería resolverlo de forma más integrada.

# Obtener logger
log = logging.getLogger(__name__)


# --- FUNCIÓN PRINCIPAL CON ESTRATEGIA REVISADA (Mojibake -> unicode_escape) ---
import os
import logging
import shutil
import json
import codecs
import re # Import re

log = logging.getLogger(__name__)

# --- Helper function _validar_y_normalizar_ruta (Assume robust implementation) ---
def _validar_y_normalizar_ruta(ruta_relativa, ruta_base_abs, asegurar_existencia=False):
    """ Robust path validation """
    # Placeholder - use the robust implementation from previous steps
    try:
        ruta_relativa_norm = os.path.normpath(ruta_relativa)
        if os.path.isabs(ruta_relativa_norm) or ruta_relativa_norm.startswith('..'):
            # log.error(f"Suspicious relative path: '{ruta_relativa}' -> '{ruta_relativa_norm}'")
            return None
        if not os.path.isabs(ruta_base_abs):
            # log.error(f"Base path is not absolute: '{ruta_base_abs}'")
            return None
        ruta_base_real = os.path.realpath(ruta_base_abs)
        if not os.path.isdir(ruta_base_real):
            # log.error(f"Real base path is not a directory: '{ruta_base_real}'")
            return None
        ruta_candidata_abs = os.path.join(ruta_base_real, ruta_relativa_norm)
        ruta_candidata_abs_norm = os.path.normpath(ruta_candidata_abs)
        ruta_candidata_real = os.path.realpath(ruta_candidata_abs_norm)
        if os.path.commonprefix([ruta_base_real, ruta_candidata_real]) == ruta_base_real:
            if asegurar_existencia and not os.path.exists(ruta_candidata_real):
                # log.warning(f"Validated path does not exist: '{ruta_candidata_real}'")
                return None
            # log.debug(f"Validated path: '{ruta_candidata_abs_norm}'")
            return ruta_candidata_abs_norm
        else:
            # log.error(f"Path Traversal Attempt! Relative path '{ruta_relativa}' exits base '{ruta_base_real}'. Result: '{ruta_candidata_real}'")
            return None
    except Exception as e:
        # log.error(f"Error during path validation for '{ruta_relativa}' in '{ruta_base_abs}': {e}", exc_info=True)
        return None


# --- Mojibake common replacements ---
# Maps common Mojibake (UTF-8 bytes misinterpreted as Latin-1/CP1252 chars) to correct UTF-8 chars
# Order matters if sequences overlap (e.g., 'Ã©' before 'Ã') - put longer/more specific first? Unlikely here.
MOJIBAKE_REPLACEMENTS = {
    # Two-byte UTF-8 sequences often misinterpreted
    "Ã¡": "á", "Ã©": "é", "Ã­": "í", "Ã³": "ó", "Ãº": "ú", "Ã¼": "ü",
    "Ã": "Á", "Ã‰": "É", "Ã": "Í", "Ã“": "Ó", "Ãš": "Ú", "Ãœ": "Ü",
    "Ã±": "ñ", "Ã‘": "Ñ",
    "Â¡": "¡", "Â¿": "¿",
    "Âª": "ª", "Âº": "º",
    "Â«": "«", "Â»": "»",
    # Three-byte UTF-8 sequences (less common via simple Latin-1 mistake, but possible via CP1252 etc.)
    "â‚¬": "€", # Euro
    "â„¢": "™", # Trademark
    "â€™": "’", # Right single quote (common CP1252 issue)
    "â€˜": "‘", # Left single quote
    "â€œ": "“", # Left double quote
    "â€": "”", # Right double quote
    "â€¦": "…", # Ellipsis
    # Add more as needed based on observed Mojibake
}

# --- FUNCIÓN PRINCIPAL (Estrategia: Replace Mojibake -> unicode_escape) ---
def aplicarCambiosSobrescritura(archivos_con_contenido, rutaBase, accionOriginal, paramsOriginal):
    """
    Applies changes generated by Gemini.
    - FIRST replaces common Mojibake sequences using a predefined map.
    - THEN decodes standard escape sequences (\\n, \\t, \\uXXXX, \\\\) using 'unicode_escape'.
    - Writes files in UTF-8. Handles delete/create actions.
    """
    logPrefix = "aplicarCambiosSobrescritura:"
    log.info(f"{logPrefix} Applying changes for original action '{accionOriginal}'...")
    rutaBaseNorm = os.path.normpath(rutaBase)

    # --- Handle delete_file, create_directory (Simplified for brevity, use robust impl.) ---
    if accionOriginal in ["eliminar_archivo", "crear_directorio"]:
        if accionOriginal == "eliminar_archivo":
            targetRel = paramsOriginal.get("archivo") or paramsOriginal.get("directorio")
            if not targetRel: return False, f"Missing target parameter for {accionOriginal}."
            targetAbs = _validar_y_normalizar_ruta(targetRel, rutaBaseNorm, asegurar_existencia=False)
            if targetAbs is None: return False, f"Invalid/unsafe path for {accionOriginal}: '{targetRel}'"
            log.info(f"{logPrefix} Executing action '{accionOriginal}': Targeting {targetRel}")
            if os.path.exists(targetAbs):
                try:
                    if os.path.isfile(targetAbs) or os.path.islink(targetAbs): os.remove(targetAbs); log.info(f"{logPrefix} File/Link deleted.")
                    elif os.path.isdir(targetAbs): os.rmdir(targetAbs); log.info(f"{logPrefix} Empty directory deleted.") # Only empty
                    else: return False, f"Target '{targetRel}' is not a file/link/directory."
                    return True, None
                except OSError as e: return False, f"OS Error deleting '{targetRel}': {e}" # e.g., non-empty dir
                except Exception as e: return False, f"Error deleting '{targetRel}': {e}"
            else: log.warning(f"{logPrefix} Target '{targetRel}' not found for deletion."); return True, None
        elif accionOriginal == "crear_directorio":
            dirRel = paramsOriginal.get("directorio")
            if not dirRel: return False, "Missing 'directorio' parameter."
            dirAbs = _validar_y_normalizar_ruta(dirRel, rutaBaseNorm, asegurar_existencia=False)
            if dirAbs is None: return False, f"Invalid/unsafe path for crear_directorio: '{dirRel}'"
            log.info(f"{logPrefix} Executing action '{accionOriginal}': Creating {dirRel}")
            if os.path.exists(dirAbs):
                if os.path.isdir(dirAbs): log.warning(f"{logPrefix} Directory '{dirRel}' already exists."); return True, None
                else: return False, f"Path '{dirRel}' exists but is not a directory."
            else:
                try: os.makedirs(dirAbs, exist_ok=True); log.info(f"{logPrefix} Directory created."); return True, None
                except Exception as e: return False, f"Error creating directory '{dirRel}': {e}"

    # --- Initial Validations ---
    if not isinstance(archivos_con_contenido, dict):
         return False, "Argument 'archivos_con_contenido' is not a dictionary."
    if not archivos_con_contenido:
        # Only okay if action didn't require content (already handled above)
        if accionOriginal not in ["eliminar_archivo", "crear_directorio"]:
             return False, f"Empty 'archivos_con_contenido' for action '{accionOriginal}'."
        else:
            log.info(f"{logPrefix} No content provided, expected for action '{accionOriginal}'.")
            return True, None # Action was handled above

    log.info(f"{logPrefix} Processing {len(archivos_con_contenido)} file(s) for writing/modification...")
    archivosProcesados = []
    errores = []

    # --- Main loop for writing files ---
    for rutaRel, contenido_original_json in archivos_con_contenido.items():
        # --- Path validation and parent dir creation (Simplified, use robust impl.) ---
        archivoAbs = _validar_y_normalizar_ruta(rutaRel, rutaBaseNorm, asegurar_existencia=False)
        if archivoAbs is None:
            msg = f"Invalid or unsafe path ('{rutaRel}'). File skipped."
            log.error(f"{logPrefix} {msg}")
            errores.append(msg)
            continue

        # --- String type validation/conversion ---
        if not isinstance(contenido_original_json, str):
             log.warning(f"{logPrefix} Content for '{rutaRel}' is not string ({type(contenido_original_json)}). Converting to JSON.")
             try:
                 contenido_str = json.dumps(contenido_original_json, indent=2, ensure_ascii=False)
             except Exception as e_conv:
                  log.error(f"{logPrefix} Failed to convert non-string content for '{rutaRel}': {e_conv}. Skipping.")
                  errores.append(f"Invalid non-string content for {rutaRel}")
                  continue
        else:
             contenido_str = contenido_original_json

        # --- Parent Directory Creation ---
        dirPadre = os.path.dirname(archivoAbs)
        try:
            if dirPadre and not os.path.exists(dirPadre): # Check if dirPadre is not empty (for root files)
                log.info(f"{logPrefix} Creating parent directory: {dirPadre}")
                os.makedirs(dirPadre, exist_ok=True)
            elif dirPadre and not os.path.isdir(dirPadre):
                 raise ValueError(f"Parent path '{dirPadre}' exists but is not a directory.")
        except Exception as e_dir:
            msg = f"Error managing parent directory '{dirPadre}' for '{rutaRel}': {e_dir}. Skipping."
            log.error(f"{logPrefix} {msg}", exc_info=True)
            errores.append(msg)
            continue

        # --- Start Correction Block (STRATEGY: Targeted Replace FIRST) ---
        contenido_procesado = contenido_str
        log.debug(f"{logPrefix} Content ORIGINAL for '{rutaRel}' (repr): {repr(contenido_procesado[:200])}...")

        try:
            # --- STEP 1: Replace common Mojibake sequences ---
            contenido_despues_mojibake = contenido_procesado
            replacements_count = 0
            # Apply replacements iteratively
            # A simple loop is often sufficient if replacements don't create new mojibake
            for mojibake, correct in MOJIBAKE_REPLACEMENTS.items():
                if mojibake in contenido_despues_mojibake:
                    # Count occurrences before replacing for logging purposes
                    count_before = contenido_despues_mojibake.count(mojibake)
                    contenido_despues_mojibake = contenido_despues_mojibake.replace(mojibake, correct)
                    replacements_count += count_before # Add how many were replaced

            if replacements_count > 0:
                 log.info(f"{logPrefix} CORRECTION (Mojibake Replace): {replacements_count} common Mojibake sequence(s) replaced for '{rutaRel}'.")
            else:
                 log.debug(f"{logPrefix} No common Mojibake sequences found/replaced for '{rutaRel}'.")

            contenido_intermedio = contenido_despues_mojibake
            log.debug(f"{logPrefix} Content AFTER Mojibake Replace for '{rutaRel}' (repr): {repr(contenido_intermedio[:200])}...")

            # --- STEP 2: Decode standard escapes (including \uXXXX, \n, \t, \\) ---
            contenido_final = contenido_intermedio # Default if decode fails
            try:
                # Check for backslash to potentially skip decode (optimization/safety)
                if '\\' in contenido_intermedio:
                    log.debug(f"{logPrefix} Applying codecs.decode(..., 'unicode_escape') for '{rutaRel}'")
                    # Use 'backslashreplace' error handler? No, default 'strict' is better here.
                    # If an invalid escape like \z exists, it should fail.
                    contenido_decodificado = codecs.decode(contenido_intermedio, 'unicode_escape', errors='strict')

                    if contenido_decodificado != contenido_intermedio:
                        log.info(f"{logPrefix} CORRECTION (unicode_escape): Standard escape sequences decoded for '{rutaRel}'.")
                        contenido_final = contenido_decodificado
                    else:
                        log.debug(f"{logPrefix} 'unicode_escape' applied but resulted in no change.")
                else:
                    log.debug(f"{logPrefix} No backslashes found, skipping 'unicode_escape' decoding for '{rutaRel}'.")
                    # contenido_final remains contenido_intermedio

            except UnicodeDecodeError as e_escape_decode:
                 # This indicates a malformed escape sequence (e.g., "\u123" or trailing "\")
                 log.warning(f"{logPrefix} FAILED 'unicode_escape' for '{rutaRel}': {e_escape_decode}. Malformed escape sequence likely present. Using string after Mojibake replacement.")
                 # Keep contenido_final = contenido_intermedio
            except Exception as e_escape:
                 log.error(f"{logPrefix} Unexpected error during 'unicode_escape' for '{rutaRel}': {e_escape}. Using string after Mojibake replacement.", exc_info=True)
                 # Keep contenido_final = contenido_intermedio

            contenido_a_escribir = contenido_final
            log.debug(f"{logPrefix} Content AFTER unicode_escape (post-replace) for '{rutaRel}' (repr): {repr(contenido_a_escribir[:200])}...")

            # --- STEP 3: Final Diagnostics and Writing ---
            log.debug(f"{logPrefix} FINAL content to write for '{rutaRel}' (start, repr): {repr(contenido_a_escribir[:200])}")

            # Final check for remaining Mojibake (indicates uncommon Mojibake not in map)
            remaining_mojibake = [p for p in MOJIBAKE_REPLACEMENTS.keys() if p in contenido_a_escribir]
            if remaining_mojibake:
                 log.warning(f"{logPrefix} ALERT! Content for '{rutaRel}' might STILL contain Mojibake patterns AFTER processing (e.g., {remaining_mojibake[:3]}). Check MOJIBAKE_REPLACEMENTS map or input data.")

            # Final check for remaining literal \uXXXX escapes (indicates issue or intentional double-escape \\uXXXX)
            if re.search(r'\\u[0-9a-fA-F]{4}', contenido_a_escribir):
                 log.warning(f"{logPrefix} ALERT! Content for '{rutaRel}' might STILL contain literal \\uXXXX escapes AFTER processing. This could be intended if input was e.g., '\\\\uXXXX'.")

            # Write the final result in UTF-8
            log.debug(f"{logPrefix} Writing {len(contenido_a_escribir)} characters to {archivoAbs} using UTF-8")
            with open(archivoAbs, 'w', encoding='utf-8') as f:
                f.write(contenido_a_escribir)
            log.info(f"{logPrefix} File '{rutaRel}' written/overwritten successfully.")
            archivosProcesados.append(rutaRel)

        except Exception as e_process_write:
             msg = f"Error processing/writing file '{rutaRel}': {e_process_write}"
             log.error(f"{logPrefix} {msg}", exc_info=True)
             errores.append(msg)
             # Continue with the next file

    # --- End of loop ---

    # --- Final Evaluation ---
    if errores:
        error_summary = f"Process completed with {len(errores)} error(s): {'; '.join(errores[:3])}{'...' if len(errores) > 3 else ''}"
        log.error(f"{logPrefix} {error_summary}")
        return False, error_summary
    elif not archivosProcesados and archivos_con_contenido:
         msg = "Content provided but no files processed due to errors."
         log.error(f"{logPrefix} {msg}")
         return False, msg
    log.info(f"{logPrefix} Processing finished. {len(archivosProcesados)} files written/modified successfully.")
    return True, None # Success
    
# Helper de rutas (sin cambios necesarios aquí, asumiendo que funciona)
def _validar_y_normalizar_ruta(rutaRelativa, rutaBase, asegurar_existencia=False):
    logPrefix = "_validar_y_normalizar_ruta:"
    # Añadir un check inicial para None o no string
    if not rutaRelativa or not isinstance(rutaRelativa, str):
        log.error(f"{logPrefix} Se recibió una ruta relativa inválida (None o no string): {rutaRelativa!r}")
        return None
    # Resto de la función como estaba...
    log.debug(f"{logPrefix} Validando rutaRelativa='{rutaRelativa}', rutaBase='{rutaBase}', asegurar_existencia={asegurar_existencia}")
    if '..' in rutaRelativa.split(os.sep):
        log.error(f"{logPrefix} Ruta relativa inválida o sospechosa (contiene '..'): '{rutaRelativa}'")
        return None
    rutaBaseNorm = os.path.normpath(os.path.abspath(rutaBase))
    rutaRelativaNorm = os.path.normpath(rutaRelativa)
    if os.path.isabs(rutaRelativaNorm):
         log.error(f"{logPrefix} Ruta relativa '{rutaRelativa}' parece ser absoluta tras normalizar: '{rutaRelativaNorm}'. Rechazada.")
         return None
    rutaAbs = os.path.join(rutaBaseNorm, rutaRelativaNorm)
    rutaAbs = os.path.normpath(rutaAbs)

    # Comprobación de seguridad estricta
    # Asegurarse que la base termine con separador para evitar falsos positivos (ej /base vs /base_otro)
    base_con_sep = rutaBaseNorm if rutaBaseNorm.endswith(os.sep) else rutaBaseNorm + os.sep
    if not os.path.abspath(rutaAbs).startswith(os.path.abspath(base_con_sep)) and \
       os.path.abspath(rutaAbs) != os.path.abspath(rutaBaseNorm):
        log.error(f"{logPrefix} Ruta calculada '{os.path.abspath(rutaAbs)}' intenta salir de la base '{os.path.abspath(rutaBaseNorm)}' (originada de '{rutaRelativa}')")
        return None

    if asegurar_existencia and not os.path.exists(rutaAbs):
        log.warning(f"{logPrefix} La ruta requerida no existe: '{rutaAbs}' (de '{rutaRelativa}')")
        # Cambiado a False, si se pide asegurar existencia y no existe, es un fallo en ese contexto
        return None # O podría ser True dependiendo de la lógica que llama

    log.debug(f"{logPrefix} Ruta validada y normalizada a: '{rutaAbs}'")
    return rutaAbs
