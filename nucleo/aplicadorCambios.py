import os
import logging
import shutil
import json
import codecs # Import codecs
import re 

# NO BORRAR ESTE COMENTARIO
# GUIA
# ESTO CASI FUNCIONA BIEN; SE SOLUCIONO EL PROBLEMA DONDE LOS SALTOS DE LINEA DENTRO DEL CODIGO (EJEMPLO UN LOG QUE CONTENIA INDICACIONES DE SALTO DE LINEA; SE MANEA BIEN SEGUN EL TEST, Y LOS CARACTERES ASI COMO  usarÃ¡ TAMBIEN SE SOLUCIONA PERO NO SE ARREGLA Funci\\u00f3n, ¿por que? no lo se, pero rompe te toda la logica cuando se intenta, lo que se me ocurre es otra funcion que despues de que aplicarCambiosSobrescritura haga su trabajo, procesa a solucionar Funci\\u00f3n, no hay que modificar nada de lo que ya hace, sola otra etapa
# REVISIÓN: La guía sugiere una etapa extra, pero usar 'unicode_escape' en el orden correcto debería resolverlo de forma más integrada.

# Obtener logger
log = logging.getLogger(__name__)


# --- FUNCIÓN PRINCIPAL CON ESTRATEGIA REVISADA (Mojibake -> unicode_escape) ---
def aplicarCambiosSobrescritura(archivos_con_contenido, rutaBase, accionOriginal, paramsOriginal):
    """
    Applies changes generated by Gemini.
    - Overwrites existing files or creates new ones with provided content.
    - Handles actions like delete_file and create_directory.
    - FIRST decodes standard escape sequences (\\n, \\t, \\uXXXX, \\\\) using 'unicode_escape'.
    - THEN attempts to fix common Mojibake (UTF-8 misread as Latin-1).
    - Writes files in UTF-8.

    Args:
        archivos_con_contenido (dict): Dictionary {relative_path: content_string}.
        rutaBase (str): Absolute base path of the cloned repository.
        accionOriginal (str): The action decided by Gemini (e.g., 'modificar_codigo_en_archivo').
        paramsOriginal (dict): Parameters associated with the original action.

    Returns:
        tuple[bool, str | None]: (True, None) on success, (False, error_message) on failure.
    """
    logPrefix = "aplicarCambiosSobrescritura:"
    log.info(f"{logPrefix} Applying changes for original action '{accionOriginal}'...")
    rutaBaseNorm = os.path.normpath(rutaBase)

    # --- Handle delete_file, create_directory (Improved Validation) ---
    if accionOriginal in ["eliminar_archivo", "crear_directorio"]:
        if accionOriginal == "eliminar_archivo":
            targetRel = paramsOriginal.get("archivo") or paramsOriginal.get("directorio") # Allow deleting dirs too? Let's assume 'archivo' implies file/dir
            if not targetRel: return False, f"Missing 'archivo' or 'directorio' parameter for {accionOriginal}."
            targetAbs = _validar_y_normalizar_ruta(targetRel, rutaBaseNorm, asegurar_existencia=False) # Validate path safety
            if targetAbs is None: return False, f"Invalid or unsafe path provided for {accionOriginal}: '{targetRel}'"

            log.info(f"{logPrefix} Executing action '{accionOriginal}': Targeting {targetRel} (Abs: {targetAbs})")
            if os.path.exists(targetAbs):
                try:
                    if os.path.isfile(targetAbs) or os.path.islink(targetAbs):
                        os.remove(targetAbs)
                        log.info(f"{logPrefix} File/Link '{targetRel}' deleted.")
                    elif os.path.isdir(targetAbs):
                         # Decide if deleting non-empty dirs is allowed. Safer not to by default.
                         # Use shutil.rmtree(targetAbs) for recursive delete.
                         # For now, only delete empty dirs.
                        os.rmdir(targetAbs) # Fails if not empty
                        log.info(f"{logPrefix} Empty directory '{targetRel}' deleted.")
                    else:
                         # Should not happen if exists but not file/link/dir
                         err = f"Target '{targetRel}' exists but is not a file, link, or directory."
                         log.error(f"{logPrefix} {err}")
                         return False, err
                    return True, None
                except OSError as e: # Catch specific error for non-empty dir
                    if isinstance(e, OSError) and "Directory not empty" in str(e):
                         err = f"Cannot delete non-empty directory '{targetRel}'. Action '{accionOriginal}' may need refinement."
                         log.error(f"{logPrefix} {err}")
                         return False, err
                    else:
                         err = f"Error deleting '{targetRel}': {e}"
                         log.error(f"{logPrefix} {err}", exc_info=True)
                         return False, err
                except Exception as e:
                    err = f"Unexpected error deleting '{targetRel}': {e}"
                    log.error(f"{logPrefix} {err}", exc_info=True)
                    return False, err
            else:
                log.warning(f"{logPrefix} Target '{targetRel}' not found for deletion. Considering successful.")
                return True, None

        elif accionOriginal == "crear_directorio":
            dirRel = paramsOriginal.get("directorio")
            if not dirRel: return False, "Missing 'directorio' parameter for crear_directorio."
            dirAbs = _validar_y_normalizar_ruta(dirRel, rutaBaseNorm, asegurar_existencia=False)
            if dirAbs is None: return False, f"Invalid or unsafe path for crear_directorio: '{dirRel}'"

            log.info(f"{logPrefix} Executing action '{accionOriginal}': Creating directory {dirRel} (Abs: {dirAbs})")
            if os.path.exists(dirAbs):
                if os.path.isdir(dirAbs):
                    log.warning(f"{logPrefix} Directory '{dirRel}' already exists.")
                    return True, None
                else:
                    err = f"Path '{dirRel}' exists but is not a directory. Cannot create directory."
                    log.error(f"{logPrefix} {err}")
                    return False, err
            else:
                try:
                    os.makedirs(dirAbs, exist_ok=True) # exist_ok=True is safe here
                    log.info(f"{logPrefix} Directory '{dirRel}' created.")
                    return True, None
                except Exception as e:
                    err = f"Error creating directory '{dirRel}': {e}"
                    log.error(f"{logPrefix} {err}", exc_info=True)
                    return False, err

    # --- Initial Validations ---
    if not isinstance(archivos_con_contenido, dict):
         err = "Argument 'archivos_con_contenido' is not a dictionary."
         log.error(f"{logPrefix} {err}")
         return False, err
    if not archivos_con_contenido:
         # Allow if action didn't require content (already handled above)
         if accionOriginal not in ["eliminar_archivo", "crear_directorio"]:
             err = f"Expected content in 'archivos_con_contenido' for action '{accionOriginal}', but it's empty. Likely error in Step 2."
             log.error(f"{logPrefix} {err}")
             return False, err
         else:
             log.info(f"{logPrefix} No content in 'archivos_con_contenido', which is expected for action '{accionOriginal}'.")
             # Should have returned above if action was handled.
             return True, None # Assume success if action was handled

    log.info(f"{logPrefix} Processing {len(archivos_con_contenido)} file(s) for writing/modification...")
    archivosProcesados = []
    errores = []

    # --- Main loop for writing files ---
    for rutaRel, contenido_original_json in archivos_con_contenido.items():
        # --- Path validation and parent directory creation ---
        archivoAbs = _validar_y_normalizar_ruta(rutaRel, rutaBaseNorm, asegurar_existencia=False)
        if archivoAbs is None:
            msg = f"Invalid or unsafe path ('{rutaRel}') received from Gemini (Step 2). File skipped."
            log.error(f"{logPrefix} {msg}")
            errores.append(msg)
            continue

        # --- String type validation/conversion ---
        if not isinstance(contenido_original_json, str):
             log.warning(f"{logPrefix} Content for '{rutaRel}' is not string (type {type(contenido_original_json)}). Converting to JSON string.")
             try:
                 # Dump non-strings as JSON
                 contenido_str = json.dumps(contenido_original_json, indent=2, ensure_ascii=False)
             except Exception as e_conv:
                  log.error(f"{logPrefix} Could not convert non-string content to string for '{rutaRel}': {e_conv}. Skipping file.")
                  errores.append(f"Invalid non-string content for {rutaRel}")
                  continue
        else:
             contenido_str = contenido_original_json

        log.debug(f"{logPrefix} Processing file: {rutaRel} (Abs: {archivoAbs})")
        dirPadre = os.path.dirname(archivoAbs)
        try:
            # Create parent directories if they don't exist
            if not os.path.exists(dirPadre):
                log.info(f"{logPrefix} Creating necessary parent directory: {dirPadre}")
                os.makedirs(dirPadre, exist_ok=True)
            elif not os.path.isdir(dirPadre):
                 # If the parent path exists but is a file, raise error
                 raise ValueError(f"Parent path '{dirPadre}' for file '{rutaRel}' exists but is NOT a directory.")
        except Exception as e_dir:
            msg = f"Error creating/validating parent directory '{dirPadre}' for '{rutaRel}': {e_dir}. File skipped."
            log.error(f"{logPrefix} {msg}", exc_info=True)
            errores.append(msg)
            continue

        # --- Start Correction Block (STRATEGY: unicode_escape FIRST) ---
        contenido_procesado = contenido_str
        log.debug(f"{logPrefix} Content ORIGINAL for '{rutaRel}' (repr): {repr(contenido_procesado[:200])}...")

        try:
            # --- STEP 1: Decode standard escapes (including \uXXXX, \n, \t, \\, etc.) ---
            contenido_despues_escape = contenido_procesado # Default if decode fails
            try:
                log.debug(f"{logPrefix} Applying codecs.decode(..., 'unicode_escape') for '{rutaRel}'")
                # unicode_escape works directly on strings in Python 3
                contenido_decodificado = codecs.decode(contenido_procesado, 'unicode_escape')

                if contenido_decodificado != contenido_procesado:
                     log.info(f"{logPrefix} CORRECTION (unicode_escape): Standard escape sequences decoded for '{rutaRel}'.")
                     contenido_despues_escape = contenido_decodificado
                else:
                     log.debug(f"{logPrefix} No changes from 'unicode_escape' decoding.")

            except UnicodeDecodeError as e_escape_decode:
                 # This happens with ill-formed escapes like stray backslashes
                 log.warning(f"{logPrefix} Error decoding escapes with 'unicode_escape' for '{rutaRel}': {e_escape_decode}. Using string before escape attempt for Mojibake check.")
                 contenido_despues_escape = contenido_procesado # Use original for next step
            except Exception as e_escape:
                 log.error(f"{logPrefix} Unexpected error during 'unicode_escape' for '{rutaRel}': {e_escape}. Using string before escape attempt.", exc_info=True)
                 contenido_despues_escape = contenido_procesado # Use original for next step

            # Content ready for the Mojibake check
            contenido_intermedio = contenido_despues_escape
            log.debug(f"{logPrefix} Content AFTER unicode_escape for '{rutaRel}' (repr): {repr(contenido_intermedio[:200])}...")

            # --- STEP 2: Attempt Mojibake correction (UTF-8 misread as Latin-1) ---
            contenido_final = contenido_intermedio # Default if no correction or failure
            # Check specifically for Mojibake patterns before attempting correction
            # This avoids unnecessary encode/decode cycles and potential errors on valid UTF-8
            # Heuristic: Check for characters resulting from UTF-8 bytes misinterpreted as single-byte chars.
            # Common indicators: Ã followed by another char, Â followed by punctuation/symbol.
            needs_mojibake_check = 'Ã' in contenido_intermedio or 'Â' in contenido_intermedio
            # Add more patterns if needed, e.g., 'â‚¬', 'Å'

            if needs_mojibake_check:
                log.debug(f"{logPrefix} Potential Mojibake detected. Attempting Mojibake fix for '{rutaRel}'...")
                try:
                    # Encode the potentially mixed string (decoded escapes + mojibake) as Latin-1
                    # This WILL FAIL if unicode_escape produced chars outside Latin-1 range.
                    bytes_probables = contenido_intermedio.encode('latin-1')
                    # Decode those bytes as UTF-8
                    cadena_reconstruida_utf8 = bytes_probables.decode('utf-8')

                    # Apply only if the string changed
                    if cadena_reconstruida_utf8 != contenido_intermedio:
                        log.info(f"{logPrefix} CORRECTION (Mojibake UTF-8->Latin1->UTF-8): Applied AFTER escapes for '{rutaRel}'.")
                        contenido_final = cadena_reconstruida_utf8
                    else:
                        # This can happen if the pattern was detected but wasn't the specific UTF8->Latin1 type
                        log.debug(f"{logPrefix} Mojibake Check: String did not change after encode/decode cycle. No Mojibake correction applied.")

                except UnicodeEncodeError:
                    # This is EXPECTED if unicode_escape produced correct UTF-8 chars outside Latin-1
                    log.debug(f"{logPrefix} Mojibake Check (post-escapes): encode('latin-1') failed. Assuming content is correct UTF-8 after escapes. No Mojibake correction needed/applied.")
                    contenido_final = contenido_intermedio # Keep the result from unicode_escape
                except UnicodeDecodeError as e_moji_codec:
                     # This means encode succeeded, but the bytes weren't valid UTF-8. Input was likely corrupt.
                     log.warning(f"{logPrefix} Mojibake Check (post-escapes) for '{rutaRel}': Failed decode('utf-8') ('{e_moji_codec}'). Using result from escape decoding.")
                     contenido_final = contenido_intermedio # Keep the result from unicode_escape
                except Exception as e_moji_other:
                     log.warning(f"{logPrefix} Unexpected error during Mojibake check (post-escapes) for '{rutaRel}': {e_moji_other}. Using result from escape decoding.", exc_info=True)
                     contenido_final = contenido_intermedio # Keep the result from unicode_escape
            else:
                log.debug(f"{logPrefix} No common Mojibake patterns detected after escape decoding. Skipping Mojibake fix for '{rutaRel}'.")
                contenido_final = contenido_intermedio # Keep the result from unicode_escape

            contenido_a_escribir = contenido_final
            log.debug(f"{logPrefix} Content AFTER Mojibake Check (post-escapes) for '{rutaRel}' (repr): {repr(contenido_a_escribir[:200])}...")

            # --- STEP 3: Final Diagnostics and Writing ---
            log.debug(f"{logPrefix} FINAL content to write for '{rutaRel}' (start, repr): {repr(contenido_a_escribir[:200])}")
            log.debug(f"{logPrefix} FINAL content to write for '{rutaRel}' (end, repr): {repr(contenido_a_escribir[-200:])}")

            # Final check for remaining Mojibake (indicates issue in logic or very corrupt input)
            mojibake_patterns = ['Ã', 'Â', 'â', 'Å'] # Simplified check
            if any(pattern in contenido_a_escribir for pattern in mojibake_patterns):
                 # More detailed pattern matching could be done here if needed
                 log.warning(f"{logPrefix} ALERT! Content for '{rutaRel}' might STILL contain Mojibake patterns AFTER final processing. Review logs.")

            # Final check for remaining literal \uXXXX escapes (indicates issue or intentional double-escape)
            if re.search(r'\\u[0-9a-fA-F]{4}', contenido_a_escribir):
                 log.warning(f"{logPrefix} ALERT! Content for '{rutaRel}' might STILL contain literal \\uXXXX escapes AFTER final processing.")

            # Write the final result in UTF-8
            log.debug(f"{logPrefix} Writing {len(contenido_a_escribir)} characters to {archivoAbs} using UTF-8")
            with open(archivoAbs, 'w', encoding='utf-8') as f:
                f.write(contenido_a_escribir)
            log.info(f"{logPrefix} File '{rutaRel}' written/overwritten successfully.")
            archivosProcesados.append(rutaRel)

        except Exception as e_process_write:
             # Catch errors during the processing/writing of a specific file
             msg = f"Error processing/writing file '{rutaRel}': {e_process_write}"
             log.error(f"{logPrefix} {msg}", exc_info=True)
             errores.append(msg)
             # Continue with the next file

    # --- End of loop ---

    # --- Final Evaluation ---
    if errores:
        error_summary = f"Process completed with {len(errores)} error(s): {'; '.join(errores[:3])}{'...' if len(errores) > 3 else ''}"
        log.error(f"{logPrefix} {error_summary}")
        return False, error_summary
    elif not archivosProcesados and archivos_con_contenido:
         # All files provided failed processing
         msg = "Content was provided but no files could be processed due to errors (see logs)."
         log.error(f"{logPrefix} {msg}")
         return False, msg
    # No errors, or only errors were handled (like file not found on delete)
    log.info(f"{logPrefix} Processing finished. {len(archivosProcesados)} files written/modified successfully.")
    return True, None # Success


    
# Helper de rutas (sin cambios necesarios aquí, asumiendo que funciona)
def _validar_y_normalizar_ruta(rutaRelativa, rutaBase, asegurar_existencia=False):
    logPrefix = "_validar_y_normalizar_ruta:"
    # Añadir un check inicial para None o no string
    if not rutaRelativa or not isinstance(rutaRelativa, str):
        log.error(f"{logPrefix} Se recibió una ruta relativa inválida (None o no string): {rutaRelativa!r}")
        return None
    # Resto de la función como estaba...
    log.debug(f"{logPrefix} Validando rutaRelativa='{rutaRelativa}', rutaBase='{rutaBase}', asegurar_existencia={asegurar_existencia}")
    if '..' in rutaRelativa.split(os.sep):
        log.error(f"{logPrefix} Ruta relativa inválida o sospechosa (contiene '..'): '{rutaRelativa}'")
        return None
    rutaBaseNorm = os.path.normpath(os.path.abspath(rutaBase))
    rutaRelativaNorm = os.path.normpath(rutaRelativa)
    if os.path.isabs(rutaRelativaNorm):
         log.error(f"{logPrefix} Ruta relativa '{rutaRelativa}' parece ser absoluta tras normalizar: '{rutaRelativaNorm}'. Rechazada.")
         return None
    rutaAbs = os.path.join(rutaBaseNorm, rutaRelativaNorm)
    rutaAbs = os.path.normpath(rutaAbs)

    # Comprobación de seguridad estricta
    # Asegurarse que la base termine con separador para evitar falsos positivos (ej /base vs /base_otro)
    base_con_sep = rutaBaseNorm if rutaBaseNorm.endswith(os.sep) else rutaBaseNorm + os.sep
    if not os.path.abspath(rutaAbs).startswith(os.path.abspath(base_con_sep)) and \
       os.path.abspath(rutaAbs) != os.path.abspath(rutaBaseNorm):
        log.error(f"{logPrefix} Ruta calculada '{os.path.abspath(rutaAbs)}' intenta salir de la base '{os.path.abspath(rutaBaseNorm)}' (originada de '{rutaRelativa}')")
        return None

    if asegurar_existencia and not os.path.exists(rutaAbs):
        log.warning(f"{logPrefix} La ruta requerida no existe: '{rutaAbs}' (de '{rutaRelativa}')")
        # Cambiado a False, si se pide asegurar existencia y no existe, es un fallo en ese contexto
        return None # O podría ser True dependiendo de la lógica que llama

    log.debug(f"{logPrefix} Ruta validada y normalizada a: '{rutaAbs}'")
    return rutaAbs
